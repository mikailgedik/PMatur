% !TeX spellcheck = en_US
\documentclass[10pt,a4paper,titlepage]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{graphicx}
\usepackage[left=2.00cm, right=2.00cm, top=2.00cm, bottom=2.00cm]{geometry}
\usepackage{tikz}
\usepackage{tikz-uml}
\usetikzlibrary{patterns}%for tikz https://tex.stackexchange.com/questions/54464/hatch-a-rectangle-in-tikz
%sources
\usepackage[backend=bibtex]{biblatex}
\bibliography{Thesis}
%Makes index browsable in pdf viewers and shows index in sidebar
\usepackage[bookmarks]{hyperref}
\author{Mikail Gedik}
\title{Thesis Paper}
\begin{document}
	\pagenumbering{roman}
	\maketitle
	\tableofcontents
	\listoffigures
	\clearpage
	\pagenumbering{arabic}
	\section{Abstract}
	This paper tackles the calculation of a few selected fractals and shines light on the core aspects I have implemented and furthermore optimized to use all the resources provided by the computer. My journey begins at a single threaded Java program and ends in a multi threaded C application able to make use graphics cards. Additionally, I will make an easy-to use yet powerful UI, which will enable even tech-unfamiliar people to use my software.
	
	
	\section{What is a Fractal}
	Fractals are complex geometric shapes with special properties. But in contrast to normal finite Euclidean shapes (such as the circle, sphere, cube etc.), fractals are infinite. The angles and the lines of a cube are indifferent from the magnification. Fractals have the property that no matter how much they are magnified or zoomed into, the edges are never smooth but rough. New levels of detail will appear. Surprisingly, some fractals can even contain themselves. This property (well seen in the Sierpinski triangle, figure \ref{fig:sierpinski_triangle}) is called self-similarity. Although the self-similarity in this example is perfect, many fractals contain non-perfect copies of themselves. This can often be observed in nature, for example tree branches or snowflakes (figure \ref{fig:snowflake}).\\
	There are different types of fractals: geometric, algebraic and naturally occurring. Geometric and algebraic fractals are created by repeating a process over and over again. The Sierpinski triangle repeatedly cuts out the center piece of each black triangle \ref{fig:sierpinski_triangle_build}. The algebraic ones iterate have to iterate over an equation to determine its shape.\\
	While they were first conceptualized by Felix Hausdorff in 1918, the term fractal (from Latin fragmented, broken) was only coined in 1975 by mathematician Benoit B. Mandelbrot. A factor in this long time span were the invention of computers, which made the exploration of fractals much easier due to their impressive computation power. Mandelbrot used fractals as a tool to examine the stock market, but were also found to be useful in various fields like physical chemistry, fluid mechanics and physiology. \cite{FractalFoundation}, \cite{FractalFoundation}, \cite{britannica}.
	\begin{figure}[h]
		\caption{Sierpi?ski triangle [\cite{Sierpinski}]}
		\label{fig:sierpinski_triangle}
		\centering
		\includegraphics[width=0.5\textwidth]{"res/images/1000px-Sierpinski_triangle.svg.png"}
	\end{figure}
	\begin{figure}[h]
		\caption{Each branch of the snowflake creates new smaller branches \cite{wikipedia_snowflake}}
		\label{fig:snowflake}
		\centering
		\includegraphics[width=0.5\textwidth]{"res/images/bentley_snowflake.jpg"}
	\end{figure}
	\begin{figure}[h]
		\caption{Creation of the Sierpinski triangle}
		\label{fig:sierpinski_triangle_build}
		\centering
		\begin{tikzpicture}[scale=3]
			\fill[black] (0,0) -- (1.118,0) -- (1.118/2, 1);
			
			\draw[rounded corners, dashed, red, ultra thick] (1.118/2, 0) -- (1.118/4*3,.5) -- (1.118/4, .5) -- (1.118/2, 0);
		\end{tikzpicture}
		\begin{tikzpicture}[scale=3]
			\fill[black] (0,0) -- (1.118033989,0) -- (1.118033989/2, 1);
			\fill[white] (1.118/2, 0) -- (1.118/4*3,.5) -- (1.118/4, .5);
			
			\draw[rounded corners, dashed, red, ultra thick] (1.118/4*3, 0) -- (1.118/8*5,.25) -- (1.118/8*7, .25) -- (1.118/4*3, 0);
			\draw[rounded corners, dashed, red, ultra thick] (1.118/4, 0) -- (1.118/8,.25) -- (1.118/8*3, .25) -- (1.118/4, 0);
			\draw[rounded corners, dashed, red, ultra thick] (1.118/2, .5) -- (1.118/8*3,.75) -- (1.118/8*5, .75) -- (1.118/2, .5);
		\end{tikzpicture}
		\begin{tikzpicture}[scale=3]
			\fill[black] (0,0) -- (1.118033989,0) -- (1.118033989/2, 1);
			
			\fill[white] (1.118/2, 0) -- (1.118/4*3,.5) -- (1.118/4, .5);
			
			\fill[white] (1.118/4*3, 0) -- (1.118/8*5,.25) -- (1.118/8*7, .25);
			\fill[white] (1.118/4, 0) -- (1.118/8,.25) -- (1.118/8*3, .25);
			\fill[white] (1.118/2, .5) -- (1.118/8*3,.75) -- (1.118/8*5, .75);
		\end{tikzpicture}
	\end{figure}
	
	%finite fractal contains infinity/self-similarity. occurs in nature. equally rough at all scales. not possible to understand with classical geometry\cite{FractalsForDummies}.\\
	%Never ending repeating branching pattern. (Infinitely complex). Made by repeating simple process often. Geometric fractals created by repeating simple process (sierpinski triangle). Algebraic fractals: repeat equation over and over \cite{FractalFoundation}:\\
	%complex geometric shapes. Concept by Felix Hausdorff 1918. Are distinct from classical/Euclidean geometry (square, circle, sphere etc.). spatially nonuniform phenomena in nature (coastlines, mountain ranges). Word fractal (Latin for "fragmented", "broken") by mathematician Benoit B. Mandelbrot. Fractals as tools for different fields (stock market). Self-similar objects have remain invariant under changes of scale: they have scaling symmetry. Fractal dimension vs. euclidean dimension, a noninteger. Fractals are used to simulate nature (e. g. tree branches)\cite{britannica}
	
	\section{The Mandelbrot Set}
	Although the most part of my thesis paper is dedicated to computer science the necessity arises to explain the most used fractal in my work. The Mandelbrot set was named after Benoit Mandelbrot, and is the first one to be called a fractal. In terms of properties, it is related to the Julia set, which is not a part of my work, albeit my program has the ability to display them. The Mandelbrot set is an algebraic fractal in the complex plane \(z = a + b i\). To find out which points are part of the set, we have to repeatedly apply the function \(z_{n+1} = z_{n}^2 + c\) to every point \(z\) in the plane. If the point diverges (or is known to diverge) as \(n\) approaches infinity, it is said to be outside the set. The most interesting points lie at the boundary of the set, as the edge is the most interesting part of any fractal.
	
	%named after benoit mandelbrot. related to julia set. choose complex number \(c\) and \(z_0\) and repeatedly put into equation \(z_n = z_{n+1} + c\). If \(z_n\) diverges, point not in fractal. Interesting points near boundary \cite{freeuk}
	
	\section{Program Capabilities \& Expectations}
	Here I will be listing all capabilities my program should have, from easiest to hardest.
	\subsection{General}
	\subsubsection{Operating System Independence}
	As a Linux user, I am heavily outnumbered by Windows and Mac users. Because of this, my software has to run on the other platforms, or else very few people will be able to test or run my program. Due to me beginning the project in Java, this will only become an issue when switching to C++. I will be using the Vulkan API to use video cards, which is also platform independent and shouldn't cause any issues.
	\subsection{Backend}
	\subsubsection{Basic Java Single Threaded Mandelbrot Set Calculation}
	The first goal is to make a simple Java program, which will calculate the Mandelbrot set and output the result into a file. It is not yet intended to be structurally divided and good as shown in figure \ref{fig:program_structure} (Page \pageref{fig:program_structure}), but more closely together as there are yet not enough parts to separate the code.\\
	Next up would be the implementation of the settings using a simple database like a list.
	\subsubsection{Basic Java Single Threaded Mandelbrot Set Calculation}
	\subsection{Windowed Frontend}
	\subsection{Other Known Programs}
	
	\section{Program Structure}
	
	%\begin{tikzpicture}
	%	\begin{umlpackage}[x=0,y=0]{package-name}
	%	\end{umlpackage}
	%\end{tikzpicture}
	
	My program is separated in two halves, the front- and backend. While the latter is autonomous, the former is dependent on the backend, as it must know its interface, which is the connecting bridge between them. The front-end can request or order a command through a command string or an integer, i. e. a character sequence or a number. The backend answer these with a command result, which may also be an image.\\
	Because the backend is detached from the front-end, I may also develop multiple front-ends for different needs. The front-end in the diagram below shows a possible version of window-oriented front-end, which is relatively modern and user-friendly, but for example useless in a command line environment. Thus I see the need to develop different front-ends.
	
		\begin{figure}
			\centering
			\caption{Program structure}
			\begin{tikzpicture}
			%Front/Backend-connection
			\draw[red, ultra thick, <-] (5,6.5) -- (7,6.5);
			\node[above, align=center] at (6,6.5) {Command\\String};
			
			\draw[red, ultra thick, <-] (5,5) -- (7,5);
			\node[above, align=center] at (6,5) {Command\\Integer};
			
			\draw[red, ultra thick, ->] (5,3.5) -- (7,3.5);
			\node[below, align=center] at (6,3.5) {Command\\Result};
			
			\draw[red, ultra thick, ->] (5,2) -- (7,2);
			\node[below, align=center] at (6,2) {Image\\Result};
			
			%Backend
			\draw (0,0) rectangle (5,8);
			\node[above] at (2.5, 8) {\textbf{Backend}};
			
			%Interface
			\draw (4,1) rectangle (5, 7);
			\node[rotate = 90] at(4.5, 4) {Backend Interface};
			
			%Settings
			\draw (.5,7.2) rectangle (4.5, 7.8);
			\node at (2.5, 7.5) {Settings};
			
			%Fractal calculator
			\draw (1.5,4) rectangle (3.5, 6.5);
			\node[align=center] at (2.5, 5.25) {Fractal\\Calculator};
			
			%Image render
			\draw (1.5,1) rectangle (3.5, 3.5);
			\node[align=center] at (2.5, 2.25) {Image\\Render};
			
			%File handling
			\draw (0,1) rectangle (1, 7);
			\node[rotate = 90] at(.5, 4) {File Handler};
			
			%Arrows
			%Settings-Frac
			\draw[ultra thick, ->] (2.5, 7.2) -- (2.5, 6.5);
			%Int-Frac
			\draw[ultra thick, <-] (3.5, 5.5) -- (4, 5.5);
			%Frac-Image
			\draw[ultra thick, ->]  (2.5, 4) -- (2.5, 3.5);
			%Img-Int
			\draw[ultra thick, ->]  (3.5, 2.5) -- (4, 2.5);
			%Frac-File
			\draw[ultra thick, <->] (1.5, 5.5) -- (1, 5.5);
			%Image-File
			\draw[ultra thick, ->] (1.5, 2.5) -- (1, 2.5);
			%Settings-Int
			\draw[ultra thick, ->] (4, 6.5) -- (3.75, 6.5) -- (3.75, 7.2); 
			%Int-File
			\draw[ultra thick, <->] (4.5, 1) -- (4.5,.5) -- (.5,.5) -- (.5, 1);
			
			%File system
			\draw[green, ultra thick, dashed, ->] (-.25, 3.5) -- (.25, 3.5);
			\draw[green, ultra thick, dashed, <-] (-.25, 4.5) -- (.25, 4.5);
			\node[rotate = 90] at (-.5, 4) {File System};
			
			%Frontend
			\draw (7,0) rectangle (12,8);
			\node[above] at (9.5, 8) {\textbf{Windowed Front-end}};
			
			%Interface
			\draw (7,1) rectangle (8, 7);
			\node[rotate = 90] at(7.5, 4) {Front-end Interface};
			
			%Main
			\draw (7.25,7.2) rectangle (11.75, 7.8);
			\node at (9.5, 7.5) {Main/Frontend-controller};
			
			%Window
			\draw (8.5,4) rectangle (11.75, 6.5);
			\node[align=center] at (10.125, 5.25) {Window};
			
			%Control Panels
			\draw (8.5,1) rectangle (10.5, 3.5);
			\node[align=center] at (9.5, 2.25) {Control\\Panels};
			
			%Listener
			\draw (11,1) rectangle (12, 3.5);
			\node[rotate = 90] at(11.5, 2.25) {Listener};
			
			%Arrows
			%Main-Win
			\draw[ultra thick, <->] (10.125 ,7.2) -- (10.125, 6.5);
			%List-Win
			\draw[ultra thick, ->] (11.5, 3.5) -- (11.5,4);
			%Ctr-Win
			\draw[ultra thick, <->] (9.5, 3.5) -- (9.5, 4);
			%Main-Interface
			\draw[ultra thick, <->] (8, 6.75) -- (8.5, 6.75) -- (8.5, 7.2);
			
			%Ctr-Interface
			\draw[ultra thick, <-] (8, 2.25) -- (8.5, 2.25);
			
			%Keyboard/Mouse
			\draw[green, ultra thick, dashed, ->] (11.5, 5.25) -- (12.25,5.25);
			\node[rotate = 90] at (12.5, 5.25) {Display};
			
			\draw[green, ultra thick, dashed, <-] (11.75, 2.25) -- (12.25, 2.25);
			\node[rotate = 90] at (12.5, 2.25) {Keyboard/Mouse};
			\end{tikzpicture}
			
			\label{fig:program_structure}
		\end{figure}

	\subsection{Backend}
	The backend consists of multiple components or modules, which are tightly bound together. Each of them is responsible for a certain task and should not do anything else. The modules are only capable of communicating to each other, but not to the `outside'. Only the interface and the file handler may connect with the front-end or the file system respectively.
	\subsubsection{Interface}
	The interface is responsible for a fast and reliable communication with the operating system and the front-end. In essence, all it has to do is accept orders from the outside, validate them and pass them on to the corresponding component in the backend. If the command expects a result, the interface will return it.
	\subsubsection{Settings}
	The settings store variables which are used in computation. It can be roughly divided in two parts, the mathematical and informational half. The former is concerned with parameters concerning the fractal, i. e. the expected width and height, the viewport and other parameters (for example the \(C\) in the Julia-Set), while the latter stores information which are necessary to know for optimizations, like the thread count of the processor, the available RAM and disk space and more technical details. Although the name settings suggests that these are variable, some may be constant through the program's life cycle and must not be altered in any way, like the CPU's name.
	\subsubsection{Fractal Calculator}
	Upon receiving the command from the interface, the fractal calculator starts to calculate a set of points according to the parameters fetched from the settings module. After having created all necessary information to start the rendering process, the calculation's result is given either to the image render module or to the file handler. The fractal calculator is the core part of my thesis paper and I will spend most of my time tinkering with and finding optimizations for it.
	\subsubsection{Image Render Module}
	Having calculated the appearance of a fractal is not the same as showing it on the display. The image render module is capable of turning an array of points into an image. While this is rather simple with 2D fractals, it becomes and more of challenge for 3D fractals or even multidimensional fractals. Anybody who has already had some experience in 3D rendering knows that there is more to it than just shapes. Lighting and sampling are a game changer in this regard and make an image more pleasing to look at.\\
	After rendering the image, it is sent to the interface or to the file handler to save a copy to the local disk.
	\subsubsection{File Handler}
	This module can connect to the local file system and read or write data there. It also compresses or decompresses it to save disks space or to optimize the disk read process. The data written there are either images of fractals, videos zooming into a fractal or raw compressed information of it.
	\subsection{Frontend}
	The frontend is the mediator between the backend and the user. It makes the program's capabilities, which are invoked through methods and functions, available to humans, which can only (without considering voice commands or touch screens) interfere with the computer by mouse and keyboard. The frontend takes commands, which are issued by mouse clicks or keyboard strokes, and forwards them to the backend. These commands usually yield a result, which is reported back to the frontend and shown to the user. For all this, a window is needed.
	\subsection{Connection between Front- and Backend}
	As any API, the backend provides a way to interact with it. The connecting piece is called \verb|Connector| in the java version. Because of the modularization, the frontend's access is restricted to only this class. While that may sound cumbersome, it brings the advantage that I can perform fundamental changes (as long as the connector is not changed) to the backend without changing anything in the frontend.
	
	\section{Version History}
	In this section we will take a look at the creation history of my program and discuss its most important aspects. Because not every version brings noteworthy changes with themselves, I have chosen split the log in two parts; All the important changes will be noted here, the lesser relevant are in the appendix \ref{appendix:version_history} (page \pageref{appendix:version_history}).
	\subsection{Java Version}
	\subsubsection{Java 0.0.1 (68b6e0e)}
	When running the program, you may notice that the timings are not as expected. Here is a sample output:
	\begin{verbatim}
	Version: Java 0.0.1
	Time to calculate fractal: 00064 ms
	Time to calculate image:   01287 ms
	Saved image to: /home/mikail/Desktop/File.png
	Time to save image:        00023 ms
	\end{verbatim}
	As you can see, generating the actual data took way less time than transforming the data into an image. This is due to the data not being aligned with the pixels of the image. In contrast to the first version, the \verb|MandelbrotCalculator| is not aware of the specifications of the image (i. e. location, size and resolution) and is only informed about the rough area it has to calculate. As a result, the \verb|MandelbrotCalculator| creates a dataset that will only approximately match the pixels of the image, if at all. When the dataset is used by the \verb|ImageCreator|, it has to search the next nearest value for each pixel, leading to tremendous render times. The figure \ref{fig:java_data_in_grid} (Page \pageref{fig:java_data_in_grid}) shows this behavior visually.\\
	The reasoning behind this is quite simple: On one hand, the data set does not have to match the image created in the end. This makes it easy to create cropped images, images with a lower resolution (if needed) and the like. On the other hand, multidimensional fractals cannot be stored in 2D-image arrays. Although I have yet only created 2D images, I want to create a future-proof way of saving the data. Another advantage is removing the redundancy: As clearly seen in any plain example image, there are a lot of recurring patterns. In the Mandelbrot set (or any fractal for that matter), I am primarily interested in what is in and what is not in the fractal. So instead of saving each point, it would be much easier to save only the dividing line between the two areas. Thus, using an image to save the data set ceases to be an option, and I have to use my own way to save the data. This comes with the cost of of losing the ability to compress the data, because the algorithms for these run only on images, and not on custom defined data sets. Lastly, I want to address the issue with the time: I am aware of the fact that it is not acceptable that the rendering takes more time than calculating. I will try to tackle this issue in a further version.
	\begin{figure}[h!]
		\centering
		\caption{Comparison between the two models}
		\label{fig:java_data_in_grid}
		\begin{tikzpicture}[xscale=-1]
		\draw[pattern=north west lines, pattern color=green] (5, 0) rectangle (6,1);
		\draw[pattern=north west lines, pattern color=yellow] (6, 0) rectangle (7,1);
		\draw[pattern=north west lines, pattern color=cyan] (5, 1) rectangle (6,2);
		\draw[pattern=north west lines, pattern color=red] (6, 1) rectangle (7,2);
		
		\draw[step=1.0,black] (0, 0) grid (2,2);
		
		\foreach \x in {0.5,..., 1.5} {
			\foreach \y in {0,..., 1} {
				\draw[-] (\x, {\y + 0.33 * (\x + 0.5)}) -- (\x + 2.5, {\y + 0.33 * (\x + 0.5)});
			}
		}
		
		\draw [->, color=green]  (3, .33) -- (5.5, .33);
		\draw [->, color=yellow] (3.5, .66) -- (6.5, .66);
		\draw [->, color=cyan]   (3, 1.33) -- (5.5, 1.33);
		\draw [->, color=red]    (3.5, 1.66) -- (6.5, 1.66);
		
		\node[align=center] at (3.5 ,2.5) {Each pixel\\ calculates a value};
		
		\draw[step=1,black] (5, 0) grid (7, 2);
		
		\draw[dashed] (-1,-.5) -- (8, -.5);
		\draw[dashed] (-1,3) -- (8, 3);
		\end{tikzpicture} \\
		\begin{tikzpicture}[scale=-1]
		%first fill circles with gray, then draw border later
		\foreach \x in {
			{0.1, 1.44},{1.47, 0.95},{0.61, 0.59},{1.66, 1.7},{0.71, 1.06},{0.79, 0.86},{1.27, 1.14},{0.06, .2},{1.99, 1.77},{1.5, 0.07}} {
			\fill[gray] (\x) circle[radius=.1];
		}
		
		\fill[color=green] (0.06, .2)  circle[radius=.1];
		\fill[color=yellow] (1.5, 0.07) circle[radius=.1];
		\fill[color=cyan] (0.1, 1.44) circle[radius=.1];
		\fill[color=red] (1.66, 1.7) circle[radius=.1];
		
		\draw[pattern=north west lines, pattern color=green] (5, 0) rectangle (6,1);
		\draw[pattern=north west lines, pattern color=yellow] (6, 0) rectangle (7,1);
		\draw[pattern=north west lines, pattern color=cyan] (5, 1) rectangle (6,2);
		\draw[pattern=north west lines, pattern color=red] (6, 1) rectangle (7,2);
		
		%draw borders of circles after color has been drawn
		\foreach \x in {
			{0.1, 1.44},{1.47, 0.95},{0.61, 0.59},{1.66, 1.7},{0.71, 1.06},{0.79, 0.86},{1.27, 1.14},{0.06, .2},{1.99, 1.77},{1.5, 0.07}} {
			\draw (\x) circle[radius=.1];
		}
		
		
		\draw [->] (0.06, .2) -- (5.5, .5);
		\draw [->] (1.5, 0.07) -- (6.5, .5);
		\draw [->] (0.1, 1.44) -- (5.5, 1.5);
		\draw [->] (1.66, 1.7) -- (6.5, 1.5);
		
		\node[align=center] at (3.5 ,2.4) {Each pixel\\has to search for the nearest\\calculated value};
		
		\draw[step=1,black] (5, 0) grid (7, 2);
		\end{tikzpicture}
	\end{figure}
	\subsubsection{Java Version 0.0.3 (fcaf89f) - First UI}
	A simple UI has been added. The UI consists of the rendered image and log in the center, a refresh button in the south and a menu bar. Currently, only the \verb|save|, \verb|close| and \verb|Open settings| menuitems are working. Saving brings up a dialog where one can choose where to export the image (currently, only \verb|png| is supported). When opening the settings, a dialog with all the changeable options comes up. Upon changing, make sure to hit the \verb|Save and exit| button. The program is smart enough to only update the entries that were changed.\\
	The main aspect is the image in the center. When using the mouse wheel on it, one can zoom in and out of the set. With drag and drop, one can move around in the image. However, because on each iteration the program has to recalculate the image, it may take a long time to just move on pixel to the side.
	
	
	\section{Key Functionalities}
	In this section I will explain the key functionalities of my program schematically, i. e. how the algorithms work. Naturally, there are often multiple approaches on how to solve a problem, resulting in having different solutions for the same problem. However, they are not equal in execution time and resource management, thus bringing diverse advantages (and disadvantages) in different situations.
	\subsection{Image Structure}
	After the image has been generated from the data, it is stored in a bitmap (i. e. in a raster). The underlying implementation uses a one-dimensional array. Before generation, the viewport has to be specified. It defines the area which has to be rendered.\\
	Notice that the width and height are defined twice. Once for the image, and once for the viewport. These two values are not to be confused. The dimensions of the image describe the amount of pixels, and therefore the resolution. Changing these values will not move you around in the fractal or change your view, but you will see the image with more precision and it will appear less blurred.\\
	The dimensions of the viewport describe the sector of the fractal which is rendered. The viewport also contains a start point, which the image dimension lacks. Moving around the point will move the area up and down or rather left and right. Changing the width and height will zoom in and out of the image and stretch it.\\
	One big problem here is the aspect ratio. Assume that the viewport specifies a width of 10 and a height of 5, but the image is 100 pixels tall and wide. The aspect ratios are 2:1 and 1:1 respectively. The result will be a squashed/stretched image as seen in figure \ref{fig:aspect_ratio} (Page \pageref{fig:aspect_ratio}).
		\begin{figure}[h!]
		\centering
		\caption{Image versus Viewport}
		\label{fig:image_viewport}
		\begin{tikzpicture}
		\draw[step=.5,black] (0, 0) grid (4,3);
		
		\draw[|-|] (0, -.2) -- (2,  -.2) node[below] {Image width} -- (4, -.2);
		\draw[|-|] (0, 3.2) -- (2,  3.2) node[above] {Viewport width} -- (4, 3.2);
		
		\draw[|-|] (-.2, 0) -- (-.2, 1.5) node[left] {Image heigth} -- (-.2, 3);
		\draw[|-|] (4.2, 0) -- (4.2, 1.5) node[right] {Viewport heigth} -- (4.2, 3);
		
		\fill (0,0) circle[radius=.075] node [below left, align=left] {Viewport\\Start (x,y)};
		\end{tikzpicture}
	\end{figure}
	\begin{figure}[h!]
		\centering
		\caption{Aspect Ratio Problem Visualized}
		\label{fig:aspect_ratio}
		\begin{tikzpicture}
		\node at(2.5,1.25) {\includegraphics[width=5cm,height=2.5cm]{./res/images/stretch_1.png}};
		\node at(8.5,2.5) {\includegraphics[width=5cm,height=5cm]{./res/images/stretch_2.png}};
		
		\node[below] at (2.5, 0) {Viewport};
		\node[below] at (8.5, 0) {Image};
		
		\draw[step=.5, red] (0, 0) grid (5,2.5);
		\draw[step=.5, red] (5.9999, 0) grid (11,5);
		
		\end{tikzpicture}
	\end{figure}
	\subsection{Data}
	Data calculated can be stored in many ways, from simple arrays to complex databanks. I have taken different approaches on how the data is stored
	\subsubsection{Directly in Image}
	The data is stored directly in the image, i. e. each pixel represents a coordinate and is given a color representing its value (currently white if it is in the set, pink otherwise). The big advantage is that the calculation can be directly shown on screen; i. e. there is no conversion between from data to the image, giving a good performance. Disadvantages are that it is not flexible. Assume that one wants to move around or zoom into the image. A new image has to be created, and if the old and new viewport overlap, some data might be recyclable. If a third image has to be produced, the program has to look at two different images to calculate the new image instead of one dataset.
	\subsubsection{Simple List}
	The data is stored in an list, each value consist of a pair of coordinates and a value. To create an image, we assign each pixel a coordinate and iterate over the list to get the value at that location of the set. The disadvantage is the aforementioned fact: to find the value of a pixel, the whole list has to be searched. This is a very time-costly operation and leads to the absurd fact that it takes less time to create the list than the image. However, adding elements is easy, as they only have to appended to the end of the list.
	\subsubsection{Grid List}
	Storing the data in a grid (figure \ref{fig:grid_list}, page \pageref{fig:grid_list}) has the advantage that we always know where a certain point in the dataset is and thus do not have to search for it. The disadvantages are the fixed size. On creation, the size and location of the datapoints have to be set and cannot be changed afterwards. This means that this type is unsuitable for dynamic datasets, where there new data is calculated continuously and added to the dataset. To add more data, a new grid has to be created and all the old (usable) data has to be copied into the new location, which is drains the available memory.
	\begin{figure}[h!]
		\centering
		\caption{A Grid}
		\label{fig:grid_list}
		\begin{tikzpicture}[scale=2]
		\draw[->] (1,-.5) node[right] {List} -- (1,-.1);
		\draw[->] (-.5,1.125) node[left, align=right] {Entry number\\33} -- (-.1,1.125);
		
		\foreach \x in {
			1,2,3,4,5,6,7,8} {
			\foreach \y in {1,2,3,4,5,6,7,8} {
				\foreach \num [evaluate = \num] in {int(\x + \y * 8 - 8)} {
					\node at (\x / 4 - .125, \y / 4 - .125) {\num};
				}
			}
		}
		
		\draw[step=.25, black, thick] (0, 0) grid (2,2);

		\end{tikzpicture}
	\end{figure}
	\subsubsection{Multiple Recursive Sorted Lists}
	The next version I came up with consists of lists containing lists. As seen in figure \ref{fig:cluster} (page \pageref{fig:cluster}), there is a mainlist containing four black quadrants. Similar to figure \ref{fig:grid_list} (page \pageref{fig:grid_list}), each square contains a value. However, the squares are not limited to have a single value. When new data is calculated in the region of the first square, the data can be stored in a new sublist. A sublist is a list which can contain values, or even new sublists. As seen in the figure, the sublist is structually the same as the mainlist, but the position and size are altered.\\
	In the figure below, the mainlist is colored black and contains four sublists (red, green, blue and violet). The red sublist contains a cyan sub-sublist, or sublist of second order. The distance between the datapoints shrinks exponentially with the order of the sublist they are in.
	
	\begin{figure}[h!]
		\centering
		\caption{List in lists}
		\label{fig:cluster}
		\begin{tikzpicture}[scale=2]
			\draw[step=.25, cyan] (.5,.5) grid (1,1);
			\draw[step=.5, red] 	(0,0) grid (1,1);
			\draw[step=.5, blue] 	(0,1) grid (1,2);
			\draw[step=.5, green] 	(1,0) grid (2,1);
			\draw[step=.5, violet] 	(1,1) grid (2,2);
			\draw[step=1.0,black, ultra thick] (0, 0) grid (2,2);
			
			\draw[->, red] (-1.3, .5) node[below] {First Sublist} -- (-.1,.5);
			\draw[->, green]	(3.3, .5) node[below] {Second Sublist} -- (2.1,.5);
			\draw[->, blue] (-1.3, 1.5) node[above] {Third Sublist} -- (-.1, 1.5);
			\draw[->, violet] (3.3, 1.5) node[above] {Fourth Sublist} -- (2.1,1.5);
			\draw[->, cyan] (-1.3, .75) node[left, align = right] {Sublist of second order} -- (.4,.75);
			\draw[->] (1,-.5) node[right] {Mainlist} -- (1,-.1);
		\end{tikzpicture}
	\end{figure}

	\section{Libraries}
	Used (or planned) libraries:\\
	ffmpeg for video\\
	PPM (self coded for debugging)\\
	stb for PNG (https://github.com/nothings/stb)\\
	
	\appendix
	\section{Complete Version History}\label{appendix:version_history}
	\subsection{Java Version}
	This is the Java version written in Java.
	\subsubsection{Initializer (6bdf295)}
	This commit existed for the sole purpose of creating the repository and verifying that it actually works.
	\subsubsection{First Version}
	Because the very first version was a simple one-file program, I decided against committing it. But for legacy purposes, I will shortly explain what the code did: It simply made an image and calculated the value of each pixel and saved the result in a file. It was all single threaded and made no use of any optimization.
	\subsubsection{Java 0.0.1 (68b6e0e)}
	According to the figure \ref{fig:program_structure} (Page \pageref{fig:program_structure}), the components are now separated in different classes and packages. The ''parent'' package is called \verb|ch.mikailgedik.kzn.matur| and contains the following sub-packages, which names should be self-explanatory: \verb|calculator|, \verb|filemanager|, \verb|render|, \verb|settings|. The only outcast is the \verb|MainClass.java| file, which lies directly in the parent package. It combines the classes and has more of a testing character than an actual use. This is due to the lack of an existing interface and frontend.\\
	\begin{table}[h!]
		\centering
		\label{tab:java_0_0_1}
		\caption{Changelog for Java 0.0.1}
		\begin{tabular}{p{.3 \textwidth}|p{.7 \textwidth}}
			Class name & Class description \\ 
			\hline 
			\verb|CalculationResult|&  This class stores the calculated information in an \verb|ArrayList|, which is initialized by the constructor with a given size. I have done this because each time the list has to be resized, all the elements in it have to be copied into a new array. Another feasible approach to solve the resizing problem would have been to use a \verb|LinkedList|, as they can be expanded instantly and use only as much memory as they are big, but their performance suffers greatly when accessed randomly (as opposed to sequentially). \newline
			The datatype stored in the list is defined as a generic type, and is currently the \verb|CalculationResult.DataMandelbrot| class. Furthermore, the class implements the \verb|Iterable| interface, so that it can be used in \verb|foreach| loops. \\
			\hline 
			\verb|CalculationResult.|\linebreak \hspace*{50 pt}\verb|DataMandelbrot|& This class stores one calculated point of the Mandelbrot set. The coordinates are stored as two doubles named \verb|x| and \verb|y|, the actual value is a boolean called \verb|value|, which is true for all points in the set and false for all the others.\\ 
			\hline 
			\verb|MandelbrotCalculator|& This class does the actual mathematics regarding the Mandelbrot set. The generation is started by calling the method \verb|calculate|, which then returns an instance of \verb|CalculationResult| with all the calculated points.
			Apart from that it also holds an instance of the settings, meaning that other components must access this one to get a hold on the settings, like defining the viewport. \\ 
			\hline
			\verb|FileManager|& This is the class which interacts with the filesystem. It is currently useless, because it implements a sole method, which saves an image to a file. I have only included this class, so all the code related to saving will not end up in a random class but in a specific one. This way the requirement of modularization is being fulfilled. \\ 
			\hline
			\verb|ImageCreator|& The image creator converts raw data to an image. For now, it only has to create an image from the data retrieved from the \verb|MandelbrotCalculator|. The challenge here is that the calculated points' coordinates do not match the exact coordinates of the image. Thus, each pixel has to search for the nearest point in the data set. This is a lengthy process, but I will go into more detail below. \\ 
			\hline 
			\verb|SettingsManager|& The \verb|SettingsManager| contains all preset parameters and information required to calculate the fractal. The settings are stored in a \verb|LinkedHashMap| and accessible through the methods provided. The elements of the list must implement the \verb|Setting| interface and its inherited method \verb|identifier()|. There are currently only two settings available, the \verb|SettingViewport| and the \verb|SettingNumber|, which store data for the viewport and data that can be expressed in scalars respectively. \\ 
			\hline 
			\verb|TestMain|& As the name suggests, this mainclass is only here to test the components. It replaces a proper frontend, which I have not yet created because of the big amount of work associated with it. \\ 
		\end{tabular} 
	\end{table}
	
	\subsubsection{Java 0.0.2 (892e1e0)}
	This version updates the \verb|SettingsManager| to use a \verb|TreeMap| with strings as keys and objects as values. Previously, all the settings were sorted by their type in different classes (e.g. \verb|SettingViewport|). As of now, the settings are stored ordered (for performance reasons) in a \verb|TreeMap|. The main advantage is that adding a new setting is now not as cumbersome as it was before, because it suffices to add a new entry by calling the \verb|SettingsManager.addSetting(String name, Object value)| instead of having to create a new class for it or add an additional field. The drawbacks are longer retrieving times, as the whole map has to be searched for every value rather than retrieving one class and getting the value of one of its fields. Aside from this, the default settings are not hardcoded anymore but stored in a file named \verb|resources/settings/defaultsettings|. The \verb|resources| directory contains all files related to resources, i. e. data required for the program (in contrast to executable code).\\
	In order to address the values without to type out the whole key, constants exists in the \verb|SettingsManager|. Their names should be self-explanatory. Values are retrieved by calling the \verb|SettingsManager.get(String name)| method. However, because the datatype of the setting is often already known, I have also implemented a few methods which automatically convert the value to a given type (\verb|getI|, \verb|getD| and \verb|getS| for integers, doubles and strings respectively). These methods throw an exception the setting requested does not exist.\\
	Aside from the these changes, I made minor adjustments in the \verb|FileManager| class. All other classes have only be changed to accustom the new \verb|SettingsManager| class

	\printbibliography
\end{document}